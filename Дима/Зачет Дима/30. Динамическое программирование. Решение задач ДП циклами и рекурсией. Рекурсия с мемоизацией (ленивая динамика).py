"""
Рассмотрим сравнение динамического программирования с рекурсивными решениями вычисления чисел Фибоначчи.
Для тех, кто забыл, в одну строчку это решение можно записать так:
"""


def fib_rec(n):
    return 1 if n < 2 else fib(n - 2) + fib(n - 1)


"""
Это решение неплохое, но время выполнения здесь растет экспоненциально, асимптотическая сложность оценивается как 2^n.
Человек, имея рядом листочек и ручку (и норм голову), решит эту задачу гораздо быстрее.
Он решает эту задачу от простого к сложному, т.е. рассчитывает число для более маленьких чисел, а потом идет к большим.
В этом состоит и динамическое программирование: от простого к сложному.
Теперь рассмотрим решение нашей задачи именно динамическим программированием. Нахождение числа Фибонначи будет выглядеть
так:
"""


def fib(n):
    dp = [0, 1] + [0] * (n - 1)  # создается список необходимого размера, начинающийся 0 и 1 (бронируется место)
    for i in range(2, n + 1):  # находятся все числа Фибоначчи со 2 и заканчивая n
        dp[i] = dp[i - 1] + dp[i - 2]  # используем рекуррентную формулу

    return dp[n]


"""
Это решение лучше, чем рекурсивное.
Как оно работает?
При каждом вызове рекурсивной функции на стек кладется текущий номер числа и адрес возврата.
Поэтому нужная память здесь - 2n.
"""
